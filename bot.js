const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, ChannelType, PermissionFlagsBits, SlashCommandBuilder, REST, Routes } = require('discord.js');
const express = require('express');

const app = express();
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.MessageContent
    ]
});

// CONFIGURA√á√ÉO - COLE SEUS IDs AQUI
const CONFIG = {
    colors: {
        primary: 0x5865F2,
        success: 0x57F287,
        warning: 0xFEE75C,
        error: 0xED4245
    },
    
    // üî• COLE SEUS IDs REAIS AQUI:
    roles: {
        support: '1427009496210739373',      // ID do cargo de suporte
        admin: '1410304623251554461'           // ID do cargo de admin
    },
    
    channels: {
        ticket_logs: '1424551958575845376',     // ID do canal de logs
        ticket_create: '1418009011386843226'   // ID do canal de criar tickets
    },
    
    categories: {
        open_tickets: '1418008982404071595',   // ID da categoria tickets abertos
        closed_tickets: '1430556193125830786' // ID da categoria tickets fechados
    },
    
    messages: {
        welcome_title: 'üé™ Sistema de Tickets',
        welcome_description: 'Selecione o tipo de suporte abaixo:',
        ticket_created: 'üé´ **Ticket Criado!**',
        close_confirm: 'üîí **Fechar Ticket?**'
    },
    
    ticket_types: [
        {
            label: 'üíº Suporte Geral',
            description: 'D√∫vidas gerais',
            emoji: 'üíº',
            value: 'general'
        },
        {
            label: 'üí∞ Suporte Vendas',
            description: 'Ajuda com compras',
            emoji: 'üí∞',
            value: 'sales'
        }
    ]
};

// Sistema de debug
function debug(message, data = null) {
    console.log(`üîç DEBUG: ${message}`, data || '');
}

// Slash Commands
const commands = [
    new SlashCommandBuilder()
        .setName('ticket')
        .setDescription('Sistema de tickets')
        .addSubcommand(subcommand =>
            subcommand
                .setName('setup')
                .setDescription('Configurar sistema de tickets'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('debug')
                .setDescription('Verificar configura√ß√£o do sistema'))
];

const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
const tickets = new Map();

client.on('ready', async () => {
    console.log(`ü§ñ Bot ${client.user.tag} online!`);
    
    try {
        await rest.put(Routes.applicationCommands(client.user.id), { body: commands });
        console.log('‚úÖ Slash commands registrados!');
        client.user.setActivity('/ticket setup', { type: 'PLAYING' });
    } catch (error) {
        console.error('‚ùå Erro ao registrar commands:', error);
    }
});

// COMANDO: /ticket debug - VERIFICA A CONFIGURA√á√ÉO
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isChatInputCommand()) return;

    if (interaction.commandName === 'ticket') {
        const subcommand = interaction.options.getSubcommand();

        if (subcommand === 'debug') {
            await interaction.deferReply({ ephemeral: true });

            const guild = interaction.guild;
            let debugInfo = 'üîç **DEBUG - CONFIGURA√á√ÉO DO SISTEMA**\n\n';

            // Verificar cargos
            debugInfo += '**üë• CARGOS:**\n';
            const supportRole = guild.roles.cache.get(CONFIG.roles.support);
            const adminRole = guild.roles.cache.get(CONFIG.roles.admin);
            
            debugInfo += `üé´ Suporte: ${supportRole ? '‚úÖ ENCONTRADO' : '‚ùå N√ÉO ENCONTRADO'} (ID: ${CONFIG.roles.support})\n`;
            debugInfo += `üëë Admin: ${adminRole ? '‚úÖ ENCONTRADO' : '‚ùå N√ÉO ENCONTRADO'} (ID: ${CONFIG.roles.admin})\n\n`;

            // Verificar canais
            debugInfo += '**üìä CANAIS:**\n';
            const logsChannel = guild.channels.cache.get(CONFIG.channels.ticket_logs);
            const createChannel = guild.channels.cache.get(CONFIG.channels.ticket_create);
            
            debugInfo += `üìÅ Logs: ${logsChannel ? '‚úÖ ENCONTRADO' : '‚ùå N√ÉO ENCONTRADO'} (ID: ${CONFIG.channels.ticket_logs})\n`;
            debugInfo += `üé´ Criar: ${createChannel ? '‚úÖ ENCONTRADO' : '‚ùå N√ÉO ENCONTRADO'} (ID: ${CONFIG.channels.ticket_create})\n\n`;

            // Verificar categorias
            debugInfo += '**üìÇ CATEGORIAS:**\n';
            const openCategory = guild.channels.cache.get(CONFIG.categories.open_tickets);
            const closedCategory = guild.channels.cache.get(CONFIG.categories.closed_tickets);
            
            debugInfo += `üé´ Abertos: ${openCategory ? '‚úÖ ENCONTRADO' : '‚ùå N√ÉO ENCONTRADO'} (ID: ${CONFIG.categories.open_tickets})\n`;
            debugInfo += `üìÅ Fechados: ${closedCategory ? '‚úÖ ENCONTRADO' : '‚ùå N√ÉO ENCONTRADO'} (ID: ${CONFIG.categories.closed_tickets})\n\n`;

            // Verificar permiss√µes do bot
            debugInfo += '**üîê PERMISS√ïES DO BOT:**\n';
            const botMember = await guild.members.fetch(client.user.id);
            const hasAdmin = botMember.permissions.has(PermissionFlagsBits.Administrator);
            const hasManageChannels = botMember.permissions.has(PermissionFlagsBits.ManageChannels);
            const hasManageRoles = botMember.permissions.has(PermissionFlagsBits.ManageRoles);
            
            debugInfo += `üëë Administrador: ${hasAdmin ? '‚úÖ' : '‚ùå'}\n`;
            debugInfo += `‚öôÔ∏è Gerenciar Canais: ${hasManageChannels ? '‚úÖ' : '‚ùå'}\n`;
            debugInfo += `üë• Gerenciar Cargos: ${hasManageRoles ? '‚úÖ' : '‚ùå'}\n`;

            const embed = new EmbedBuilder()
                .setTitle('üîç Debug do Sistema')
                .setDescription(debugInfo)
                .setColor(hasAdmin ? 0x00FF00 : 0xFF0000)
                .setTimestamp();

            await interaction.editReply({ embeds: [embed] });
            return;
        }

        if (subcommand === 'setup') {
            if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
                return await interaction.reply({ 
                    content: '‚ùå Apenas administradores podem usar este comando!', 
                    ephemeral: true 
                });
            }

            // VERIFICAR SE TUDO EXISTE ANTES DE CRIAR O PAINEL
            const guild = interaction.guild;
            let missingItems = [];

            const supportRole = guild.roles.cache.get(CONFIG.roles.support);
            const logsChannel = guild.channels.cache.get(CONFIG.channels.ticket_logs);
            const createChannel = guild.channels.cache.get(CONFIG.channels.ticket_create);
            const openCategory = guild.channels.cache.get(CONFIG.categories.open_tickets);
            const closedCategory = guild.channels.cache.get(CONFIG.categories.closed_tickets);

            if (!supportRole) missingItems.push('Cargo de Suporte');
            if (!logsChannel) missingItems.push('Canal de Logs');
            if (!createChannel) missingItems.push('Canal de Criar Ticket');
            if (!openCategory) missingItems.push('Categoria Tickets Abertos');
            if (!closedCategory) missingItems.push('Categoria Tickets Fechados');

            if (missingItems.length > 0) {
                const errorEmbed = new EmbedBuilder()
                    .setTitle('‚ùå Configura√ß√£o Incompleta')
                    .setDescription(`**Itens n√£o encontrados:**\n${missingItems.map(item => `‚Ä¢ ${item}`).join('\n')}\n\nUse \`/ticket debug\` para ver detalhes.`)
                    .setColor(0xFF0000);

                return await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }

            // SE TUDO EXISTIR, CRIAR O PAINEL
            const embed = new EmbedBuilder()
                .setTitle(CONFIG.messages.welcome_title)
                .setDescription(CONFIG.messages.welcome_description)
                .setColor(CONFIG.colors.primary);

            const selectMenu = new ActionRowBuilder()
                .addComponents(
                    new StringSelectMenuBuilder()
                        .setCustomId('ticket_type_select')
                        .setPlaceholder('üé´ Selecione o tipo de suporte...')
                        .addOptions(CONFIG.ticket_types)
                );

            await interaction.reply({ 
                content: '‚úÖ Sistema configurado com sucesso!',
                ephemeral: true 
            });

            // Enviar para o canal de cria√ß√£o de tickets
            const targetChannel = guild.channels.cache.get(CONFIG.channels.ticket_create);
            if (targetChannel) {
                await targetChannel.send({ 
                    embeds: [embed], 
                    components: [selectMenu] 
                });
            } else {
                await interaction.channel.send({ 
                    embeds: [embed], 
                    components: [selectMenu] 
                });
            }
        }
    }
});

// RESTANTE DO C√ìDIGO DOS TICKETS (MESMO DO ANTERIOR)
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isStringSelectMenu()) return;

    if (interaction.customId === 'ticket_type_select') {
        await interaction.deferReply({ ephemeral: true });

        const ticketType = interaction.values[0];
        const typeConfig = CONFIG.ticket_types.find(t => t.value === ticketType);
        const guild = interaction.guild;
        
        // VERIFICAR CATEGORIA
        const category = guild.channels.cache.get(CONFIG.categories.open_tickets);
        if (!category) {
            return await interaction.editReply({ 
                content: '‚ùå Categoria de tickets n√£o encontrada! Use `/ticket debug` para verificar.' 
            });
        }

        // VERIFICAR CARGO DE SUPORTE
        const supportRole = guild.roles.cache.get(CONFIG.roles.support);
        if (!supportRole) {
            return await interaction.editReply({ 
                content: '‚ùå Cargo de suporte n√£o encontrado! Use `/ticket debug` para verificar.' 
            });
        }

        // CRIAR TICKET
        try {
            const ticketChannel = await guild.channels.create({
                name: `ticket-${interaction.user.username}`,
                type: ChannelType.GuildText,
                parent: category.id,
                permissionOverwrites: [
                    {
                        id: guild.id,
                        deny: [PermissionFlagsBits.ViewChannel]
                    },
                    {
                        id: interaction.user.id,
                        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.ReadMessageHistory]
                    },
                    {
                        id: supportRole.id,
                        allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.ReadMessageHistory]
                    }
                ]
            });

            // Salvar ticket
            tickets.set(ticketChannel.id, {
                id: ticketChannel.id,
                author: interaction.user.id,
                type: ticketType,
                createdAt: new Date(),
                closed: false,
                claimed: false
            });

            // Embed do ticket
            const welcomeEmbed = new EmbedBuilder()
                .setTitle('üé™ Ticket de Suporte')
                .setDescription(CONFIG.messages.ticket_created)
                .addFields(
                    { name: 'üìã Tipo', value: typeConfig.label, inline: true },
                    { name: 'üë§ Autor', value: interaction.user.tag, inline: true },
                    { name: 'üïê Criado', value: `<t:${Math.floor(Date.now()/1000)}:R>`, inline: true }
                )
                .setColor(CONFIG.colors.primary);

            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('claim_ticket')
                        .setLabel('üëã Atender Ticket')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('close_ticket')
                        .setLabel('üîí Fechar Ticket')
                        .setStyle(ButtonStyle.Danger)
                );

            await ticketChannel.send({ 
                content: `${interaction.user} ${supportRole}`,
                embeds: [welcomeEmbed], 
                components: [actionRow] 
            });

            await interaction.editReply({ 
                content: `‚úÖ Ticket criado: ${ticketChannel}` 
            });

            // LOG
            const logChannel = guild.channels.cache.get(CONFIG.channels.ticket_logs);
            if (logChannel) {
                const logEmbed = new EmbedBuilder()
                    .setTitle('üìù Ticket Criado')
                    .setColor(CONFIG.colors.success)
                    .addFields(
                        { name: 'üë§ Usu√°rio', value: interaction.user.toString(), inline: true },
                        { name: 'üé´ Ticket', value: ticketChannel.toString(), inline: true },
                        { name: 'üìã Tipo', value: typeConfig.label, inline: true }
                    )
                    .setTimestamp();
                await logChannel.send({ embeds: [logEmbed] });
            }

        } catch (error) {
            console.error('Erro ao criar ticket:', error);
            await interaction.editReply({ 
                content: '‚ùå Erro ao criar ticket. Verifique as permiss√µes do bot.' 
            });
        }
    }
});

// BOT√ïES (MESMO C√ìDIGO ANTERIOR)
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isButton()) return;
    if (!tickets.has(interaction.channel.id)) return;

    const ticket = tickets.get(interaction.channel.id);

    if (interaction.customId === 'claim_ticket') {
        if (ticket.claimed) {
            return await interaction.reply({ 
                content: `‚ùå J√° atendido por <@${ticket.claimedBy}>!`, 
                ephemeral: true 
            });
        }

        ticket.claimed = true;
        ticket.claimedBy = interaction.user.id;

        const claimEmbed = new EmbedBuilder()
            .setTitle('üëã Ticket Atendido')
            .setDescription(`${interaction.user} est√° atendendo!`)
            .setColor(CONFIG.colors.success);

        await interaction.reply({ embeds: [claimEmbed] });

        // Atualizar bot√£o
        const updatedRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('claim_ticket')
                    .setLabel('‚úÖ Atendido por ' + interaction.user.username)
                    .setStyle(ButtonStyle.Success)
                    .setDisabled(true),
                new ButtonBuilder()
                    .setCustomId('close_ticket')
                    .setLabel('üîí Fechar Ticket')
                    .setStyle(ButtonStyle.Danger)
            );

        await interaction.message.edit({ components: [updatedRow] });
    }

    if (interaction.customId === 'close_ticket') {
        const confirmEmbed = new EmbedBuilder()
            .setTitle('üîí Fechar Ticket')
            .setDescription(CONFIG.messages.close_confirm)
            .setColor(CONFIG.colors.warning);

        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('confirm_close')
                    .setLabel('‚úÖ Confirmar')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('cancel_close')
                    .setLabel('‚ùå Cancelar')
                    .setStyle(ButtonStyle.Danger)
            );

        await interaction.reply({ embeds: [confirmEmbed], components: [row], ephemeral: true });
    }

    if (interaction.customId === 'confirm_close') {
        await closeTicket(interaction.channel, interaction.user);
        await interaction.message.edit({ content: '‚úÖ Ticket fechado!', components: [] });
        await interaction.deferUpdate();
    }

    if (interaction.customId === 'cancel_close') {
        await interaction.message.delete();
    }
});

async function closeTicket(channel, closer) {
    const ticket = tickets.get(channel.id);
    if (!ticket) return;

    ticket.closed = true;
    ticket.closedBy = closer.id;

    // Mover para categoria fechada
    const closedCategory = channel.guild.channels.cache.get(CONFIG.categories.closed_tickets);
    if (closedCategory) {
        await channel.setParent(closedCategory.id);
    }

    await channel.permissionOverwrites.edit(channel.guild.id, {
        SendMessages: false
    });

    const closeEmbed = new EmbedBuilder()
        .setTitle('üîí Ticket Fechado')
        .setDescription(`Fechado por ${closer}`)
        .setColor(CONFIG.colors.error);

    await channel.send({ embeds: [closeEmbed] });
}

// WEB SERVER
app.get('/', (req, res) => {
    res.json({ status: 'online', bot: client.user?.tag || 'starting' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üåê Server porta ${PORT}`);
});

client.login(process.env.DISCORD_TOKEN);           { name: 'üÜî ID do Ticket', value: `\`${channel.id}\``, inline: true }
        );

    if (type) {
        logEmbed.addFields({ name: 'üìã Tipo', value: type, inline: true });
    }

    if (action === 'closed') {
        const ticket = tickets.get(channel.id);
        if (ticket) {
            logEmbed.addFields(
                { name: '‚è±Ô∏è Dura√ß√£o', value: formatDuration(ticket.closedAt - ticket.createdAt), inline: true }
            );
        }
    }

    logEmbed.setTimestamp();

    await logChannel.send({ embeds: [logEmbed] });
}

// FORMATAR DURA√á√ÉO
function formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
}

// WEB SERVER PARA RENDER
app.use(express.json());
app.get('/', (req, res) => {
    res.json({ 
        status: 'online', 
        bot: client.user?.tag || 'starting',
        tickets: tickets.size,
        name: 'Ticket King'
    });
});

// Ping autom√°tico
setInterval(() => {
    if (process.env.RENDER_URL) {
        require('https').get(process.env.RENDER_URL);
    }
}, 14 * 60 * 1000);

const PORT = process.env.PORT || 3000;
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üåê Web server rodando na porta ${PORT}`);
});

client.login(process.env.DISCORD_TOKEN);
